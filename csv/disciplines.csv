nodeID|objective|rationale|means|tenets|practices|skills
SoftwareRequirements|Identify capabilities or qualities that the delivered solution must have in order to fulfill the customer’s needs and solve the customer’s problem.|The right solution can only be built if the desired outcomes for the customer are known.|Workshops;Collaboration Tool|Close customer collaboration;Speak the customer‘s language;Prioritize requirements;Specify measurable NFRs;Take a user‘s point of view|[Requirements Templates](https://www.volere.org/templates/volere-requirements-specification-template/);[Requirements Modeling](https://sparxsystems.com/resources/user-guides/14.0/model-domains/requirement-models.pdf);[User Stories](https://www.mountaingoatsoftware.com/agile/user-stories);[Story Maps](https://www.jpattonassociates.com/user-story-mapping/);[Event Storming](https://www.eventstorming.com/)|Domain Knowledge;Quick Comprehension;Empathy;Workshop Facilitation;Writing Skills
UserExperience|Explore and validate User Interfaces and workflows for the solution by building prototypes and testing them with representative users.|Ensure that the solution has good usability and user experience in order to avoid user errors, improve efficiency of use and enhance user acceptance.|UI Prototyping Tool;Collaboration Tool|You are not your user;Take a User-Centric viewpoint;Early Visualization;Test with real users;Test early and often|Design Workshops;User Tests and Surveys|Empathy;Quick Comprehension;Object-Orientation;Workshop Facilitation
UserInterface|Design a user interface that is easy to use as well as aesthetically pleasing. |To the user, the interface is the system. The aesthetics and usability of the User Interface influence their view of the solution as a whole.|Pen and Paper;UI Prototyping Tool;Graphic Design Tool|Use Visual Hierarchy to guide users;Use established UI Patterns;User-Centric viewpoint|[Design Systems](https://www.smashingmagazine.com/design-systems-book/);[Gestalt Principles](https://www.interaction-design.org/literature/topics/gestalt-principles);Graphic Design|Know UI Framework Capabilities and Limitations;UI Patterns and Conventions;Aesthetic Sense;Eye for Detail
SoftwareArchitecture|Define the fundamental technical concepts, structures and properties of software applications, embodied in its component structures, interfaces, relationships and behaviors.|Map the functional and non-functional requirements of the software onto a technical view to guide the subsequent implementation.|Run-Time Environments;Frameworks;Libraries;Modeling Tools|Proven Basis & No Silver Bullet;Stepwise Refinement;Separation of Concerns;Complexity Encapsulation;Component-Orientation|[Viewpoints & Perspectives](http://profi.msg.de/Individual/module.individual.design/guidances/reusableassets/resources/15-Architecture-Viewpoints-and-Perspectives-msg.pdf);[MeTA](http://profi.msg.de/Individual/module.individual.design/guidances/supportingmaterials/praesentation_meta_9D958A3D.html);Weighted Decision Matrix;[Back of the Envelope Calc.](http://profi.msg.de/Individual/module.individual.design/guidances/reusableassets/resources/16-Back-of-the-Envelope-Calculations-msg.pdf);Technology Life-Cycles|Technology Overview;Programming;Open Source Licensing
SystemArchitecture|Represent a system by mapping functionality onto hardware and software components, and mapping the software architecture onto the operational architecture.|Every software solution must fit into its surrounding IT landscape and define reliable and efficient deployment and operations procedures.|Modelling Tools;Architecture Description Languages|Document strategic decisions;Strive for simplicity;The Customer is the Judge of Quality|Enterprise Architecture;Cloud-Native Architecture;Hardware Sizing|Technology Overview;Virtualization Overview;Cloud Technology Overview
DomainModeling|Manage domain complexity by specifying an abstraction of the solution that fulfills the requirements.|Domain Models can help achieve a shared understanding of how the solution solves the customer’s problem.|Modeling Tool;Unified Modeling Language;Whiteboard Sketches;Workshops|Create Big Picture of solution domain;Identify domain components;Identify clear solution boundaries|[Object-Oriented Analysis & Design](https://www.craiglarman.com/wiki/index.php?%20title=Book_Applying_UML_and_Patterns);[Object-Oriented Software Engineering](https://www.ivarjacobson.com/publications/books/object-oriented-software-engineering-1992);[Domain-Driven Design](https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20)|Domain Knowledge;Object-Orientation;Architecture Knowledge;Workshop Facilitation
SoftwareVersioning|Record and trace changes to source artifacts during development, in order to coordinate work between multiple persons, revert changes and reproduce a specific set of source artifacts at any time |All source artifacts contributing to a solution need to be versioned, reproducible and safely stored. Often, distributed development and several variants of the solution need to be supported.|Version Control Systems|Reproducibility;Traceability|Branches & Tags;Maturity Level;Versioning Schemes|Release Management
SoftwareAssembly|Automated transition from source code to the executable application.|A schematic, tedious, fine-granular procedure that is frequently repeated, calls for automation.|Build Automation Tools;Build Procedure|Automation;Forward/Backward Steps|Feature Toggles;Continuous Integration (CI);Short-Circuit Paths|Build Management;Configuration Management
SoftwareDeployment|Reliably install a software distribution into a specific environment.|Software is developed to be executed.|Deployment Tool;Deployment Procedure;Infrastructure as Code (IaC)|Single Responsibility Principle;Traceability;Reproducibility|Continuous Deployment (CD);Deployment Automation;Separation of Environments;Dependency Management|System Administration
SoftwareOperations|Run software reliably, cost-efficiently and highly available.|Running software is the only way to gain benefit from it. Running smoothly is the basis for a great solution outcome.|Support / Repair / Escalation Workflows;Issue Tracker|High Availability;Proactive System Hygiene;Automation;Infrastructure Resiliency|Active Monitoring;Log Aggregation;Failover Precautions;Service Level Agreement;Contingency Planning|System Administration
SoftwareTest|Systematically verify functional and non-functional requirements by executing (parts of) the solution.|Before being used productively, every solution needs to undergo a systematic investigation of the quality achieved. Finding major quality flaws in production can have disastrous effects.|Test Management Tools;Test Automation Tools|Determine if the solution is fit for use;Risk based Testing;Adequate Test Automation|[Usability Testing](https://www.usability.gov/how-to-and-tools/methods/usability-testing.html);[White Box Testing](http://softwaretestingfundamentals.com/white-box-testing/);[Black Box Testing](http://softwaretestingfundamentals.com/black-box-testing/)|Requirements Knowledge;Testing;Test Automation
SoftwareReview|Regularly examine software artifacts for adherence to the architecture and suitability for the requirements. Software Reviews may be informal (peer reviews) or formal (management reviews).|An agreed software architecture is useless if it is not implemented in software artifacts, esp. source code. Reviews can be supported by analysis tools, but should rely on experienced software craftsmen. |Modeling Tools;Static Analysis Tools;Code Review Tools;Collaboration Tools|Strive for simplicity;Don’t blame;Reviewing is Coaching|Architecture/Design Review;[Pair Programming](https://martinfowler.com/articles/on-pair-programming.html);Code Review;[Coding Standards](https://www.multidots.com/importance-of-code-quality-and-coding-standard-in-software-development/)|Architecture Knowledge;Requirements Knowledge;Software Craftsmanship
UsageDocumentation|Provide the user with unobtrusive and – if needed – detailed guidance for using the IT product(s) that form the solution. |Not every feature of a solution is obvious to use or even easy to find. The user should be supported by easy to grasp, yet complete documentation of available functionality.|Solution embedded Help;Online/Offline Documentation;Screencasts;Videos|Simplicity;User-Centric viewpoint;Language of the User|Examples;Frequently Asked Questions;Glossary|Technical Writing;Domain Knowledge;Solution Knowledge
UserTraining|Provide the user with in-depth training in order to fully leverage the solution.|Solutions for complex domains cannot be learned only by usage or reading the documentation. Trainings, possibly in different levels and formats, are needed to use the solution effectively.|Live Training;Online Courses|Outcome Orientation;Practical Usage;Learning by feedback from attendees|Visualization;Examples;Learning by Doing;Team Exercises;[User Certification](https://training.apple.com/us/en/recognition)|Domain Experience;Solution Knowledge;Training Skills
SoftwareImplementation|Efficiently transform requirements into executable, tested software, while adhering to the solution’s specified architecture.|Executable Software is the only dependable measure of progress while realizing a solution. Frequent customer feedback on implemented functionality is key to building the right product. |Languages;Frameworks;Libraries;Development Environments|Separation of Concerns;Information Hiding;DRY – Don’t Repeat Yourself;Divide and Conquer|Design Patterns;Data Modeling;Design Systems;Debugging;Unit Testing|Software Craftsmanship;Knowledge of Development Ecosystems;Domain Knowledge;Solution related Open Source Packages
SoftwareRefactoring|Improve software maintainability by restructuring existing program code, without changing its external behavior.|Adding features without refactoring steadily deteriorates software, because it increases technical debt, eventually leading to unmaintainable software.|Static Code Analyzers;Development Environments|Refactor in small steps;Refactor regularly;Automate Tests|Coding Standards;Design Patterns;Test Driven Development|Software Craftsmanship;Domain Knowledge
